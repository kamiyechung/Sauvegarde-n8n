{
  "active": false,
  "connections": {
    "Anthropic Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Structured Output Parser",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "AI Agent1",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Structured Output Parser1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "MCP Notion": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          },
          {
            "node": "AI Agent1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "Get many database pages Prestataire",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get many database pages Cat√©gorie",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "AI Agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "AI Agent1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get many database pages Prestataire": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get many database pages Cat√©gorie": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser1": {
      "ai_outputParser": [
        [
          {
            "node": "AI Agent1",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    }
  },
  "createdAt": "2025-10-23T15:11:16.799Z",
  "id": "1ubtTd6spRDhTiYR",
  "isArchived": false,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "name": "[Gestion des factures] Cr√©ation de libell√© AG2 bis",
  "nodes": [
    {
      "parameters": {
        "promptType": "define",
        "text": "=Tu es un assistant sp√©cialis√© en gestion de donn√©es Notion.\n\n---\n\n### üéØ OBJECTIF :\nTu re√ßois :\n- des labels de **prestataire** et de **cat√©gorie** extraits d‚Äôune facture,\n- et la **liste des pages existantes** dans Notion pour ces deux bases (Prestataires et Cat√©gories).\n\nTa mission :\n- Identifier si les libell√©s correspondent √† une entr√©e existante (m√™me libell√© ou libell√© tr√®s proche),\n- Si oui ‚Üí renvoyer son `id` existant,\n- Si non ‚Üí signaler qu‚Äôune cr√©ation est n√©cessaire (`*_to_create = true`).\n\n---\n\n### üîπ ENTR√âE :\n```json\n{\n  \"prestataire_label\": \"Google\",\n  \"categorie_label\": \"Abonnements logiciels\",\n  \"notion_prestataires\": [\n    {\"id\": \"aaa111\", \"Nom\": \"Amazon\"},\n    {\"id\": \"bbb222\", \"Nom\": \"Google France\"},\n    {\"id\": \"ccc333\", \"Nom\": \"EDF\"}\n  ],\n  \"notion_categories\": [\n    {\"id\": \"x1\", \"Nom\": \"Fournitures\"},\n    {\"id\": \"x2\", \"Nom\": \"Abonnements logiciels\"},\n    {\"id\": \"x3\", \"Nom\": \"Assurances\"}\n  ]\n}\nüîπ R√àGLES :\n\nTu peux consid√©rer comme √©quivalent : majuscules/minuscules, accents, l√©g√®res variations (ex. ‚ÄúGoogle‚Äù ‚âà ‚ÄúGoogle France‚Äù).\n\nSi aucun match n‚Äôest trouv√©, renvoie \"null\" pour l‚ÄôID et \"*_to_create\": true.\n\nNe produis aucun texte libre hors du JSON final.\n\nüîπ SORTIE ATTENDUE :\n\nRenvoie uniquement un objet JSON valide au format suivant :\n\n{\n  \"prestataire_id\": \"\",\n  \"prestataire_label\": \"\",\n  \"prestataire_to_create\": false,\n  \"categorie_id\": \"\",\n  \"categorie_label\": \"\",\n  \"categorie_to_create\": false\n}\n\nüîπ EXEMPLE :\n\nEntr√©e : (voir plus haut)\nSortie :\n\n{\n  \"prestataire_id\": \"bbb222\",\n  \"prestataire_label\": \"Google France\",\n  \"prestataire_to_create\": false,\n  \"categorie_id\": \"x2\",\n  \"categorie_label\": \"Abonnements logiciels\",\n  \"categorie_to_create\": false\n}",
        "hasOutputParser": true,
        "options": {
          "systemMessage": ""
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        704,
        -192
      ],
      "id": "3fbe8c42-db97-475b-929d-85d11eb3d4d7",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "claude-3-haiku-20240307",
          "mode": "list",
          "cachedResultName": "Claude Haiku 3"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.3,
      "position": [
        836,
        240
      ],
      "id": "3a64ce90-943d-47b5-b8a2-c8218504db04",
      "name": "Anthropic Chat Model",
      "credentials": {
        "anthropicApi": {
          "id": "ZbZl90Lb8InIiwYE",
          "name": "Anthropic account"
        }
      }
    },
    {
      "parameters": {
        "endpointUrl": "http://195.201.118.139:3001/mcp/notion",
        "serverTransport": "httpStreamable",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.mcpClientTool",
      "typeVersion": 1.1,
      "position": [
        776,
        32
      ],
      "id": "4ef767a8-73db-4bd9-a0a3-d22e34976a11",
      "name": "MCP Notion"
    },
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        256,
        -192
      ],
      "id": "29545de9-45e6-490e-9a33-4ef97755adb5",
      "name": "When Executed by Another Workflow"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"name\": \"Output Parser IA\",\n  \"nodes\": [\n    {\n      \"parameters\": {\n        \"functionCode\": \"// UNIVERSAL OUTPUT PARSER FOR LLMs\\\\n// Recovers valid JSON from noisy AI responses\\\\n\\\\nfunction getLLMText(payload) {\\\\n  const fromChoices = payload?.choices?.[0]?.message?.content;\\\\n  return (\\\\n    payload?.text ??\\\\n    payload?.response ??\\\\n    payload?.data ??\\\\n    fromChoices ??\\\\n    (typeof payload === 'string' ? payload : JSON.stringify(payload))\\\\n  );\\\\n}\\\\n\\\\nfunction stripCodeFences(s) {\\\\n  const fence = s.match(/```(?:json)?\\\\s*([\\\\s\\\\S]*?)```/i);\\\\n  return fence ? fence[1].trim() : s.trim();\\\\n}\\\\n\\\\nfunction extractBalancedJSON(s) {\\\\n  let start = -1, depth = 0;\\\\n  for (let i = 0; i < s.length; i++) {\\\\n    const ch = s[i];\\\\n    if (ch === '{') {\\\\n      if (depth === 0) start = i;\\\\n      depth++;\\\\n    } else if (ch === '}') {\\\\n      if (depth > 0) depth--;\\\\n      if (depth === 0 && start !== -1) {\\\\n        return s.slice(start, i + 1);\\\\n      }\\\\n    }\\\\n  }\\\\n  return null;\\\\n}\\\\n\\\\nfunction coerceObject(x) {\\\\n  if (Array.isArray(x) && x.length && typeof x[0] === 'object') return x[0];\\\\n  if (x && typeof x === 'object') return x;\\\\n  return null;\\\\n}\\\\n\\\\nconst rawPayload = $json;\\\\nconst rawText = getLLMText(rawPayload);\\\\nconst text = stripCodeFences(String(rawText || ''));\\\\n\\\\nlet parsed = null;\\\\n\\\\n// Try direct parse\\\\ntry { parsed = JSON.parse(text); } catch {}\\\\n\\\\n// Try balanced braces\\\\nif (!parsed) {\\\\n  const candidate = extractBalancedJSON(text);\\\\n  if (candidate) {\\\\n    try { parsed = JSON.parse(candidate); } catch {}\\\\n  }\\\\n}\\\\n\\\\n// Try last braces\\\\nif (!parsed) {\\\\n  const lastBraces = text.lastIndexOf('}');\\\\n  const firstBrace = text.indexOf('{');\\\\n  if (firstBrace !== -1 && lastBraces !== -1 && lastBraces > firstBrace) {\\\\n    const slice = text.slice(firstBrace, lastBraces + 1);\\\\n    try { parsed = JSON.parse(slice); } catch {}\\\\n  }\\\\n}\\\\n\\\\nparsed = coerceObject(parsed);\\\\n\\\\nif (!parsed) {\\\\n  return [{ json: { error: 'JSON parsing failed', raw_preview: text.slice(0, 500) } }];\\\\n}\\\\n\\\\n// Ensure n8n format\\\\nreturn [{ json: parsed }];\"\n      },\n      \"id\": \"OutputParserUniversal\",\n      \"name\": \"Output Parser IA\",\n      \"type\": \"n8n-nodes-base.function\",\n      \"typeVersion\": 1,\n      \"position\": [800, 400]\n    }\n  ],\n  \"connections\": {}\n}\n",
        "autoFix": true
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        904,
        32
      ],
      "id": "baa04f4c-75c8-4ba4-901b-cf6fc23032b6",
      "name": "Structured Output Parser"
    },
    {
      "parameters": {
        "resource": "databasePage",
        "operation": "getAll",
        "databaseId": {
          "__rl": true,
          "value": "20902d84-a064-80da-8d0d-e8ff87dab9ac",
          "mode": "list",
          "cachedResultName": "Prestataire",
          "cachedResultUrl": "https://www.notion.so/20902d84a06480da8d0de8ff87dab9ac"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.notion",
      "typeVersion": 2.2,
      "position": [
        480,
        -288
      ],
      "id": "2c882a9a-902d-41b5-8ec1-c29e3f544086",
      "name": "Get many database pages Prestataire",
      "credentials": {
        "notionApi": {
          "id": "AubRSNG8Bg4OpEMd",
          "name": "Notion account"
        }
      }
    },
    {
      "parameters": {
        "resource": "databasePage",
        "operation": "getAll",
        "databaseId": {
          "__rl": true,
          "value": "1d402d84-a064-806b-96dc-e725d1becf9a",
          "mode": "list",
          "cachedResultName": "Cat√©gories",
          "cachedResultUrl": "https://www.notion.so/1d402d84a064806b96dce725d1becf9a"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.notion",
      "typeVersion": 2.2,
      "position": [
        480,
        -96
      ],
      "id": "193133ed-1281-44b7-8fd1-9fc0fe98c064",
      "name": "Get many database pages Cat√©gorie",
      "credentials": {
        "notionApi": {
          "id": "AubRSNG8Bg4OpEMd",
          "name": "Notion account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=T√ÇCHES √Ä EFFECTUER :\n\nSi prestataire_to_create = true ‚Üí appelle le MCP Notion pour cr√©er une page :\n\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"create_page\",\n    \"arguments\": {\n      \"parent\": { \"database_id\": \"{{DATABASE_ID_PRESTATAIRES}}\" },\n      \"properties\": {\n        \"Nom\": { \"title\": [{ \"text\": { \"content\": \"{{prestataire_label}}\" } }] }\n      }\n    }\n  }\n}\n\n\nSi categorie_to_create = true ‚Üí m√™me logique pour la base ‚ÄúCat√©gories‚Äù.\n\nSi les IDs existent d√©j√† (*_to_create = false), garde-les tels quels.\n\nRetourne toujours le r√©sultat final sous la forme d‚Äôun JSON strict (sans texte explicatif).\n\nüîπ SORTIE ATTENDUE :\n\nRenvoie uniquement un objet JSON valide :\n\n{\n  \"prestataire_id\": \"\",\n  \"prestataire_label\": \"\",\n  \"categorie_id\": \"\",\n  \"categorie_label\": \"\"\n}\n\nüîπ EXEMPLE :\n\nEntr√©e :\n\n{\n  \"prestataire_id\": null,\n  \"prestataire_label\": \"Google\",\n  \"prestataire_to_create\": true,\n  \"categorie_id\": \"c2e2d84a...\",\n  \"categorie_label\": \"Abonnements logiciels\",\n  \"categorie_to_create\": false\n}\n\n\nSortie :\n\n{\n  \"prestataire_id\": \"b4b0b84a-a064-80a4-b52b-fd6d9ecb1122\",\n  \"prestataire_label\": \"Google\",\n  \"categorie_id\": \"c2e2d84a-a064-80c0-a34f-b87a112bc001\",\n  \"categorie_label\": \"Abonnements logiciels\"\n}\n\nüîπ R√àGLES :\n\nNe renvoie aucun texte libre hors du JSON.\n\nSi la cr√©ation √©choue, renvoie \"null\" pour l‚ÄôID concern√©.\n\nV√©rifie que tous les champs du JSON final soient pr√©sents.",
        "hasOutputParser": true,
        "options": {
          "systemMessage": ""
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        1280,
        -192
      ],
      "id": "8a3663b0-cd8d-44c4-84f2-41ebc758ab8f",
      "name": "AI Agent1"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"name\": \"Output Parser Agent 2b\",\n  \"nodes\": [\n    {\n      \"parameters\": {\n        \"functionCode\": \"// Universal JSON Output Parser for Agent 2b (n8n Function Node)\\n// Handles text, markdown fences, arrays, and malformed AI outputs\\n\\nfunction getLLMText(payload) {\\n  const fromChoices = payload?.choices?.[0]?.message?.content;\\n  return (\\n    payload?.text ??\\n    payload?.response ??\\n    payload?.data ??\\n    fromChoices ??\\n    (typeof payload === 'string' ? payload : JSON.stringify(payload))\\n  );\\n}\\n\\nfunction stripCodeFences(s) {\\n  const fence = s.match(/```(?:json)?\\\\s*([\\\\s\\\\S]*?)```/i);\\n  return fence ? fence[1].trim() : s.trim();\\n}\\n\\nfunction extractBalancedJSON(s) {\\n  let start = -1, depth = 0;\\n  for (let i = 0; i < s.length; i++) {\\n    const ch = s[i];\\n    if (ch === '{') {\\n      if (depth === 0) start = i;\\n      depth++;\\n    } else if (ch === '}') {\\n      if (depth > 0) depth--;\\n      if (depth === 0 && start !== -1) {\\n        return s.slice(start, i + 1);\\n      }\\n    }\\n  }\\n  return null;\\n}\\n\\nfunction coerceObject(x) {\\n  if (Array.isArray(x) && x.length && typeof x[0] === 'object') return x[0];\\n  if (x && typeof x === 'object') return x;\\n  return null;\\n}\\n\\nconst rawPayload = $json;\\nconst rawText = getLLMText(rawPayload);\\nconst text = stripCodeFences(String(rawText || ''));\\n\\nlet parsed = null;\\n\\n// Attempt direct parse\\ntry { parsed = JSON.parse(text); } catch {}\\n\\n// Try balanced braces if direct parse failed\\nif (!parsed) {\\n  const candidate = extractBalancedJSON(text);\\n  if (candidate) { try { parsed = JSON.parse(candidate); } catch {} }\\n}\\n\\n// Try last braces slice fallback\\nif (!parsed) {\\n  const lastBraces = text.lastIndexOf('}');\\n  const firstBrace = text.indexOf('{');\\n  if (firstBrace !== -1 && lastBraces !== -1 && lastBraces > firstBrace) {\\n    const slice = text.slice(firstBrace, lastBraces + 1);\\n    try { parsed = JSON.parse(slice); } catch {}\\n  }\\n}\\n\\nparsed = coerceObject(parsed);\\n\\n// Fallback if parsing fails\\nif (!parsed) {\\n  return [{ json: { error: 'JSON parsing failed (Agent 2b)', raw_preview: text.slice(0, 400) } }];\\n}\\n\\n// Enforce expected schema\\nconst schema = {\\n  prestataire_id: null,\\n  prestataire_label: null,\\n  categorie_id: null,\\n  categorie_label: null\\n};\\n\\nfor (const key in schema) {\\n  if (!(key in parsed)) parsed[key] = schema[key];\\n}\\n\\nreturn [{ json: parsed }];\"\n      },\n      \"id\": \"OutputParserAgent2b\",\n      \"name\": \"Output Parser Agent 2b\",\n      \"type\": \"n8n-nodes-base.function\",\n      \"typeVersion\": 1,\n      \"position\": [850, 350]\n    }\n  ],\n  \"connections\": {}\n}",
        "autoFix": true
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        1272,
        32
      ],
      "id": "e3765117-af8d-4c72-8d13-76ed47f3a6ee",
      "name": "Structured Output Parser1"
    }
  ],
  "origin": "n8n",
  "pinData": {},
  "repo": {
    "owner": "kamiyechung",
    "name": "Sauvegarde-n8n"
  },
  "settings": {
    "executionOrder": "v1"
  },
  "shared": [
    {
      "createdAt": "2025-10-23T15:11:16.799Z",
      "updatedAt": "2025-10-23T15:11:16.799Z",
      "role": "workflow:owner",
      "workflowId": "1ubtTd6spRDhTiYR",
      "projectId": "oALk376RbKlV8lOt"
    }
  ],
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2025-10-23T19:37:36.326Z",
  "versionId": "44a02899-beb7-482b-bb0c-604c8bb06837"
}